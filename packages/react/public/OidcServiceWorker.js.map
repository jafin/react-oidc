{"version":3,"file":"OidcServiceWorker.js","sources":["../OidcServiceWorker.ts"],"sourcesContent":["type Domain = string | RegExp;\r\n\r\ntype TrustedDomains = {\r\n    [key: string]: Domain[]\r\n}\r\ntype OidcServerConfiguration = {\r\n    revocationEndpoint: string;\r\n    issuer: string;\r\n    authorizationEndpoint: string;\r\n    tokenEndpoint: string;\r\n    userInfoEndpoint: string;\r\n}\r\n\r\ntype OidcConfiguration = {\r\n    token_renew_mode: string;\r\n    service_worker_convert_all_requests_to_cors: boolean;\r\n}\r\n\r\n\r\n// Uncertain why the Headers interface in lib.webworker.d.ts does not have a keys() function, so extending\r\ninterface FetchHeaders extends Headers {\r\n    keys(): string[];\r\n}\r\n\r\ntype Status = 'LOGGED' | 'LOGGED_IN' | 'LOGGED_OUT' | 'NOT_CONNECTED' | 'LOGOUT_FROM_ANOTHER_TAB' | 'SESSION_LOST' | 'REQUIRE_SYNC_TOKENS' | 'FORCE_REFRESH' | null;\r\ntype MessageEventType = 'clear' | 'init' | 'setState' | 'getState' | 'setCodeVerifier' | 'getCodeVerifier' | 'setSessionState' | 'getSessionState' | 'setNonce';\r\n\r\ntype MessageData = {\r\n    status: Status;\r\n    oidcServerConfiguration: OidcServerConfiguration;\r\n    oidcConfiguration: OidcConfiguration;\r\n    where: string;\r\n    state: string;\r\n    codeVerifier: string;\r\n    sessionState: string;\r\n    nonce: Nonce;\r\n}\r\n\r\ntype MessageEventData = {\r\n    configurationName: string;\r\n    type: MessageEventType;\r\n    data: MessageData;\r\n}\r\n\r\ntype Nonce = {\r\n    nonce: string;\r\n} | null;\r\n\r\ntype OidcConfig = {\r\n    configurationName: string;\r\n    tokens: Tokens | null;\r\n    status: Status;\r\n    state: string | null;\r\n    codeVerifier: string | null;\r\n    nonce: Nonce;\r\n    oidcServerConfiguration: OidcServerConfiguration | null;\r\n    oidcConfiguration?: OidcConfiguration;\r\n    sessionState?: string | null;\r\n    items?: MessageData;\r\n}\r\n\r\ntype IdTokenPayload = {\r\n    iss: string;\r\n    /**\r\n     * (Expiration Time) Claim\r\n     */\r\n    exp: number;\r\n    /**\r\n     * (Issued At) Claim\r\n     */\r\n    iat: number;\r\n    nonce: string | null;\r\n}\r\n\r\ntype AccessTokenPayload = {\r\n    exp: number;\r\n    sub: string;\r\n}\r\n\r\ntype Tokens = {\r\n    issued_at: number;\r\n    access_token: string;\r\n    accessTokenPayload: AccessTokenPayload | null;\r\n    id_token: null | string;\r\n    idTokenPayload: IdTokenPayload;\r\n    refresh_token?: string;\r\n    expiresAt: number;\r\n    expires_in: number;\r\n};\r\n\r\ntype Database = {\r\n    [key: string]: OidcConfig\r\n}\r\n\r\nconst _self = self as ServiceWorkerGlobalScope & typeof globalThis;\r\n\r\ndeclare let trustedDomains: TrustedDomains;\r\n\r\nconst scriptFilename = 'OidcTrustedDomains.js'; /* global trustedDomains */\r\n_self.importScripts(scriptFilename);\r\n\r\nconst id = Math.round(new Date().getTime() / 1000).toString();\r\n\r\nconst acceptAnyDomainToken = '*';\r\n\r\nconst keepAliveJsonFilename = 'OidcKeepAliveServiceWorker.json';\r\nconst handleInstall = (event: ExtendableEvent) => {\r\n    console.log('[OidcServiceWorker] service worker installed ' + id);\r\n    event.waitUntil(_self.skipWaiting());\r\n};\r\n\r\nconst handleActivate = (event: ExtendableEvent) => {\r\n    console.log('[OidcServiceWorker] service worker activated ' + id);\r\n    event.waitUntil(_self.clients.claim());\r\n};\r\n\r\n\r\nlet currentLoginCallbackConfigurationName: string | null = null;\r\nconst database: Database = {\r\n    default: {\r\n        configurationName: 'default',\r\n        tokens: null,\r\n        status: null,\r\n        state: null,\r\n        codeVerifier: null,\r\n        nonce: null,\r\n        oidcServerConfiguration: null,\r\n    }\r\n};\r\n\r\nconst countLetter = (str: string, find: string) => {\r\n    return (str.split(find)).length - 1;\r\n};\r\n\r\nconst b64DecodeUnicode = (str: string) =>\r\n    decodeURIComponent(Array.prototype.map.call(atob(str), (c) => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)).join(''));\r\nconst parseJwt = (token: string)  => JSON.parse(b64DecodeUnicode(token.split('.')[1].replace('-', '+').replace('_', '/')));\r\nconst extractTokenPayload = (token: string) => {\r\n    try {\r\n        if (!token) {\r\n            return null;\r\n        }\r\n        if (countLetter(token, '.') === 2) {\r\n            return parseJwt(token);\r\n        } else {\r\n            return null;\r\n        }\r\n    } catch (e) {\r\n        console.warn(e);\r\n    }\r\n    return null;\r\n};\r\n\r\nconst computeTimeLeft = (refreshTimeBeforeTokensExpirationInSecond: number, expiresAt: number) => {\r\n    const currentTimeUnixSecond = new Date().getTime() / 1000;\r\n    return Math.round(((expiresAt - refreshTimeBeforeTokensExpirationInSecond) - currentTimeUnixSecond));\r\n};\r\n\r\nconst isTokensValid = (tokens: Tokens | null) => {\r\n    if (!tokens) {\r\n        return false;\r\n    }\r\n    return computeTimeLeft(0, tokens.expiresAt) > 0;\r\n};\r\n\r\n// https://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation (excluding rules #1, #4, #5, #7, #8, #12, and #13 which did not apply).\r\n// https://github.com/openid/AppAuth-JS/issues/65\r\nconst isTokensOidcValid = (tokens: Tokens, nonce: string | null, oidcServerConfiguration: OidcServerConfiguration): {isValid: boolean, reason: string} => {\r\n    if (tokens.idTokenPayload) {\r\n        const idTokenPayload = tokens.idTokenPayload;\r\n        // 2: The Issuer Identifier for the OpenID Provider (which is typically obtained during Discovery) MUST exactly match the value of the iss (issuer) Claim.\r\n        if (oidcServerConfiguration.issuer !== idTokenPayload.iss) {\r\n            return { isValid: false, reason: 'Issuer does not match' };\r\n        }\r\n        // 3: The Client MUST validate that the aud (audience) Claim contains its client_id value registered at the Issuer identified by the iss (issuer) Claim as an audience. The aud (audience) Claim MAY contain an array with more than one element. The ID Token MUST be rejected if the ID Token does not list the Client as a valid audience, or if it contains additional audiences not trusted by the Client.\r\n\r\n        // 6: If the ID Token is received via direct communication between the Client and the Token Endpoint (which it is in this flow), the TLS server validation MAY be used to validate the issuer in place of checking the token signature. The Client MUST validate the signature of all other ID Tokens according to JWS [JWS] using the algorithm specified in the JWT alg Header Parameter. The Client MUST use the keys provided by the Issuer.\r\n\r\n        // 9: The current time MUST be before the time represented by the exp Claim.\r\n        const currentTimeUnixSecond = new Date().getTime() / 1000;\r\n        if (idTokenPayload.exp && idTokenPayload.exp < currentTimeUnixSecond) {\r\n            return { isValid: false, reason: 'Token expired' };\r\n        }\r\n        // 10: The iat Claim can be used to reject tokens that were issued too far away from the current time, limiting the amount of time that nonces need to be stored to prevent attacks. The acceptable range is Client specific.\r\n        const timeInSevenDays = 60 * 60 * 24 * 7;\r\n        if (idTokenPayload.iat && (idTokenPayload.iat + timeInSevenDays) < currentTimeUnixSecond) {\r\n            return { isValid: false, reason: 'Token is used from too long time' };\r\n        }\r\n        // 11: If a nonce value was sent in the Authentication Request, a nonce Claim MUST be present and its value checked to verify that it is the same value as the one that was sent in the Authentication Request. The Client SHOULD check the nonce value for replay attacks. The precise method for detecting replay attacks is Client specific.\r\n        if (idTokenPayload.nonce && idTokenPayload.nonce !== nonce) {\r\n            return { isValid: false, reason: 'Nonce does not match' };\r\n        }\r\n    }\r\n    return { isValid: true, reason: '' };\r\n};\r\n\r\nconst TokenRenewMode = {\r\n    access_token_or_id_token_invalid: 'access_token_or_id_token_invalid',\r\n    access_token_invalid: 'access_token_invalid',\r\n    id_token_invalid: 'id_token_invalid',\r\n};\r\n\r\nfunction hideTokens(currentDatabaseElement: OidcConfig) {\r\n    const configurationName = currentDatabaseElement.configurationName;\r\n    return (response: Response) => {\r\n        if (response.status !== 200) {\r\n            return response;\r\n        }\r\n        return response.json().then<Response>((tokens: Tokens) => {\r\n            if (!tokens.issued_at) {\r\n                const currentTimeUnixSecond = new Date().getTime() / 1000;\r\n                tokens.issued_at = currentTimeUnixSecond;\r\n            }\r\n\r\n            const accessTokenPayload = extractTokenPayload(tokens.access_token);\r\n            const secureTokens = {\r\n                ...tokens,\r\n                access_token: ACCESS_TOKEN + '_' + configurationName,\r\n                accessTokenPayload,\r\n            };\r\n            tokens.accessTokenPayload = accessTokenPayload;\r\n\r\n            let _idTokenPayload = null;\r\n            if (tokens.id_token) {\r\n                _idTokenPayload = extractTokenPayload(tokens.id_token);\r\n                tokens.idTokenPayload = { ..._idTokenPayload };\r\n                if (_idTokenPayload.nonce && currentDatabaseElement.nonce != null) {\r\n                    const keyNonce = NONCE_TOKEN + '_' + currentDatabaseElement.configurationName;\r\n                    _idTokenPayload.nonce = keyNonce;\r\n                }\r\n                secureTokens.idTokenPayload = _idTokenPayload;\r\n            }\r\n            if (tokens.refresh_token) {\r\n                secureTokens.refresh_token = REFRESH_TOKEN + '_' + configurationName;\r\n            }\r\n\r\n            const idTokenExpiresAt = (_idTokenPayload && _idTokenPayload.exp) ? _idTokenPayload.exp : Number.MAX_VALUE;\r\n            const accessTokenExpiresAt = (accessTokenPayload && accessTokenPayload.exp) ? accessTokenPayload.exp : tokens.issued_at + tokens.expires_in;\r\n\r\n            let expiresAt: number;\r\n            const tokenRenewMode = (currentDatabaseElement.oidcConfiguration as OidcConfiguration).token_renew_mode;\r\n            if (tokenRenewMode === TokenRenewMode.access_token_invalid) {\r\n                expiresAt = accessTokenExpiresAt;\r\n            } else if (tokenRenewMode === TokenRenewMode.id_token_invalid) {\r\n                expiresAt = idTokenExpiresAt;\r\n            } else {\r\n                expiresAt = idTokenExpiresAt < accessTokenExpiresAt ? idTokenExpiresAt : accessTokenExpiresAt;\r\n            }\r\n            secureTokens.expiresAt = expiresAt;\r\n\r\n            tokens.expiresAt = expiresAt;\r\n            const nonce = currentDatabaseElement.nonce ? currentDatabaseElement.nonce.nonce : null;\r\n            const { isValid, reason } = isTokensOidcValid(tokens, nonce, currentDatabaseElement.oidcServerConfiguration as OidcServerConfiguration); //TODO: Type assertion, could be null.\r\n            if (!isValid) {\r\n                throw Error(`Tokens are not OpenID valid, reason: ${reason}`);\r\n            }\r\n\r\n            // When refresh_token is not rotated we reuse ald refresh_token\r\n            if (currentDatabaseElement.tokens != null && 'refresh_token' in currentDatabaseElement.tokens && !('refresh_token' in tokens)) {\r\n                const refreshToken = currentDatabaseElement.tokens.refresh_token;\r\n                \r\n                currentDatabaseElement.tokens = { ...tokens, refresh_token: refreshToken };\r\n            } else {\r\n                currentDatabaseElement.tokens = tokens;\r\n            }\r\n\r\n            currentDatabaseElement.status = 'LOGGED_IN';\r\n            const body = JSON.stringify(secureTokens);\r\n            return new Response(body, response);\r\n        });\r\n    };\r\n}\r\n\r\nconst getCurrentDatabasesTokenEndpoint = (database: Database, url: string) => {\r\n    const databases: OidcConfig[] = [];\r\n    for (const [, value] of Object.entries<OidcConfig>(database)) {\r\n        if (value.oidcServerConfiguration != null && url.startsWith(value.oidcServerConfiguration.tokenEndpoint)) {\r\n            databases.push(value);\r\n        } else if (value.oidcServerConfiguration != null && value.oidcServerConfiguration.revocationEndpoint && url.startsWith(value.oidcServerConfiguration.revocationEndpoint)) {\r\n            databases.push(value);\r\n        }\r\n    }\r\n    return databases;\r\n};\r\n\r\nconst openidWellknownUrlEndWith = '/.well-known/openid-configuration';\r\nconst getCurrentDatabaseDomain = (database: Database, url: string) => {\r\n    if (url.endsWith(openidWellknownUrlEndWith)) {\r\n        return null;\r\n    }\r\n    for (const [key, currentDatabase] of Object.entries<OidcConfig>(database)) {\r\n        const oidcServerConfiguration = currentDatabase.oidcServerConfiguration;\r\n\r\n        if (!oidcServerConfiguration) {\r\n            continue;\r\n        }\r\n\r\n        if (oidcServerConfiguration.tokenEndpoint && url === oidcServerConfiguration.tokenEndpoint) {\r\n            continue;\r\n        }\r\n        if (oidcServerConfiguration.revocationEndpoint && url === oidcServerConfiguration.revocationEndpoint) {\r\n            continue;\r\n        }\r\n\r\n        const domainsToSendTokens = oidcServerConfiguration.userInfoEndpoint\r\n            ? [\r\n                oidcServerConfiguration.userInfoEndpoint, ...trustedDomains[key],\r\n            ]\r\n            : [...trustedDomains[key]];\r\n\r\n        let hasToSendToken = false;\r\n        if (domainsToSendTokens.find((f) => f === acceptAnyDomainToken)) {\r\n            hasToSendToken = true;\r\n        } else {\r\n            for (let i = 0; i < domainsToSendTokens.length; i++) {\r\n                let domain = domainsToSendTokens[i];\r\n\r\n                if (typeof domain === 'string') {\r\n                    domain = new RegExp(`^${domain}`);\r\n                }\r\n\r\n                if (domain.test?.(url)) {\r\n                    hasToSendToken = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (hasToSendToken) {\r\n            if (!currentDatabase.tokens) {\r\n                return null;\r\n            }\r\n            return currentDatabase;\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\nconst serializeHeaders = (headers: Headers) => {\r\n    const headersObj: Record<string,string> = {};\r\n    for (const key of (headers as FetchHeaders).keys()) {\r\n        if (headers.has(key)) {\r\n            headersObj[key] = headers.get(key) as string;\r\n        }\r\n    }\r\n    return headersObj;\r\n};\r\n\r\nconst REFRESH_TOKEN = 'REFRESH_TOKEN_SECURED_BY_OIDC_SERVICE_WORKER';\r\nconst ACCESS_TOKEN = 'ACCESS_TOKEN_SECURED_BY_OIDC_SERVICE_WORKER';\r\nconst NONCE_TOKEN = 'NONCE_SECURED_BY_OIDC_SERVICE_WORKER';\r\nconst CODE_VERIFIER = 'CODE_VERIFIER_SECURED_BY_OIDC_SERVICE_WORKER';\r\n\r\nconst sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\r\n\r\nconst keepAliveAsync = async (event: FetchEvent) => {\r\n    const originalRequest = event.request;\r\n    const isFromVanilla = originalRequest.headers.has('oidc-vanilla');\r\n    const init = { status: 200, statusText: 'oidc-service-worker' };\r\n    const response = new Response('{}', init);\r\n    if (!isFromVanilla) {\r\n        for (let i = 0; i < 240; i++) {\r\n            await sleep(1000 + Math.floor(Math.random() * 1000));\r\n            const cache = await caches.open('oidc_dummy_cache');\r\n            await cache.put(event.request, response.clone());\r\n        }\r\n    }\r\n\r\n    return response;\r\n};\r\n\r\nconst handleFetch = async (event:FetchEvent) => {\r\n    const originalRequest = event.request;\r\n    const url = originalRequest.url;\r\n    if (originalRequest.url.includes(keepAliveJsonFilename)) {\r\n        event.respondWith(keepAliveAsync(event));\r\n        return;\r\n    }\r\n\r\n    const currentDatabaseForRequestAccessToken = getCurrentDatabaseDomain(database, originalRequest.url);\r\n    if (currentDatabaseForRequestAccessToken && currentDatabaseForRequestAccessToken.tokens && currentDatabaseForRequestAccessToken.tokens.access_token) {\r\n        while (currentDatabaseForRequestAccessToken.tokens && !isTokensValid(currentDatabaseForRequestAccessToken.tokens)) {\r\n            await sleep(200);\r\n        }\r\n        const newRequest = new Request(originalRequest, {\r\n            headers: {\r\n                ...serializeHeaders(originalRequest.headers),\r\n                authorization: 'Bearer ' + currentDatabaseForRequestAccessToken.tokens.access_token,\r\n            },\r\n            mode: (currentDatabaseForRequestAccessToken.oidcConfiguration as OidcConfiguration).service_worker_convert_all_requests_to_cors ? 'cors' : originalRequest.mode,\r\n        });\r\n        \r\n        //@ts-ignore -- TODO: review, waitUntil takes a promise, this returns a void\r\n        event.waitUntil(event.respondWith(fetch(newRequest)));\r\n        \r\n        return;\r\n    }\r\n\r\n    if (event.request.method !== 'POST') {\r\n        return;\r\n    }\r\n\r\n    let currentDatabase: OidcConfig | null = null;\r\n    const currentDatabases = getCurrentDatabasesTokenEndpoint(database, originalRequest.url);\r\n    const numberDatabase = currentDatabases.length;\r\n    if (numberDatabase > 0) {\r\n        const maPromesse = new Promise<Response>((resolve, reject) => {\r\n            const clonedRequest = originalRequest.clone();\r\n            const response = clonedRequest.text().then(actualBody => {\r\n                if (actualBody.includes(REFRESH_TOKEN) || actualBody.includes(ACCESS_TOKEN)) {\r\n                    let newBody = actualBody;\r\n                    for (let i = 0; i < numberDatabase; i++) {\r\n                        const currentDb = currentDatabases[i];\r\n\r\n                        if (currentDb && currentDb.tokens != null) {\r\n                            const keyRefreshToken = REFRESH_TOKEN + '_' + currentDb.configurationName;\r\n                            if (actualBody.includes(keyRefreshToken)) {\r\n                                newBody = newBody.replace(keyRefreshToken, encodeURIComponent(currentDb.tokens.refresh_token as string));\r\n                                currentDatabase = currentDb;\r\n                                break;\r\n                            }\r\n                            const keyAccessToken = ACCESS_TOKEN + '_' + currentDb.configurationName;\r\n                            if (actualBody.includes(keyAccessToken)) {\r\n                                newBody = newBody.replace(keyAccessToken, encodeURIComponent(currentDb.tokens.access_token));\r\n                                currentDatabase = currentDb;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    const fetchPromise = fetch(originalRequest, {\r\n                        body: newBody,\r\n                        method: clonedRequest.method,\r\n                        headers: {\r\n                            ...serializeHeaders(originalRequest.headers),\r\n                        },\r\n                        mode: clonedRequest.mode,\r\n                        cache: clonedRequest.cache,\r\n                        redirect: clonedRequest.redirect,\r\n                        referrer: clonedRequest.referrer,\r\n                        credentials: clonedRequest.credentials,\r\n                        integrity: clonedRequest.integrity,\r\n                    });\r\n                    \r\n                    if (currentDatabase && currentDatabase.oidcServerConfiguration != null && currentDatabase.oidcServerConfiguration.revocationEndpoint && url.startsWith(currentDatabase.oidcServerConfiguration.revocationEndpoint)) {\r\n                        return fetchPromise.then(async response => {\r\n                            const text = await response.text();\r\n                            return new Response(text, response);\r\n                        });\r\n                    }\r\n                    return fetchPromise.then(hideTokens(currentDatabase as OidcConfig)); //todo type assertion to OidcConfig but could be null, NEEDS REVIEW\r\n                } else if (actualBody.includes('code_verifier=') && currentLoginCallbackConfigurationName) {\r\n                    currentDatabase = database[currentLoginCallbackConfigurationName];\r\n                    currentLoginCallbackConfigurationName = null;\r\n                    let newBody = actualBody;\r\n                    if (currentDatabase && currentDatabase.codeVerifier != null) {\r\n                        const keyCodeVerifier = CODE_VERIFIER + '_' + currentDatabase.configurationName;\r\n                        if (actualBody.includes(keyCodeVerifier)) {\r\n                            newBody = newBody.replace(keyCodeVerifier, currentDatabase.codeVerifier);\r\n                        }\r\n                    }\r\n\r\n                    return fetch(originalRequest, {\r\n                        body: newBody,\r\n                        method: clonedRequest.method,\r\n                        headers: {\r\n                            ...serializeHeaders(originalRequest.headers),\r\n                        },\r\n                        mode: clonedRequest.mode,\r\n                        cache: clonedRequest.cache,\r\n                        redirect: clonedRequest.redirect,\r\n                        referrer: clonedRequest.referrer,\r\n                        credentials: clonedRequest.credentials,\r\n                        integrity: clonedRequest.integrity,\r\n                    }).then(hideTokens(currentDatabase));\r\n                }\r\n                return undefined;\r\n            });\r\n            response.then(r => {\r\n                if (r !== undefined) {\r\n                    resolve(r);\r\n                } else {\r\n                    console.log('success undefined');\r\n                    reject(new Error('Response is undefined inside a success'));\r\n                }\r\n            }).catch(err => {\r\n                if (err !== undefined) {\r\n                    reject(err);\r\n                } else {\r\n                    console.log('error undefined');\r\n                    reject(new Error('Response is undefined inside a error'));\r\n                }\r\n            });\r\n        });\r\n\r\n        //@ts-ignore -- TODO: review, waitUntil takes a promise, this returns a void\r\n        event.waitUntil(event.respondWith(maPromesse));\r\n    }\r\n};\r\n\r\nconst handleMessage = (event: ExtendableMessageEvent) => {\r\n    const port = event.ports[0];\r\n    const data = event.data as MessageEventData;\r\n    const configurationName = data.configurationName;\r\n    let currentDatabase = database[configurationName];\r\n\r\n    if (!currentDatabase) {\r\n        database[configurationName] = {\r\n            tokens: null,\r\n            state: null,\r\n            codeVerifier: null,\r\n            oidcServerConfiguration: null,\r\n            oidcConfiguration: undefined,\r\n            nonce: null,\r\n            status: null,\r\n            configurationName,\r\n        };\r\n        currentDatabase = database[configurationName];\r\n        if (!trustedDomains[configurationName]) {\r\n            trustedDomains[configurationName] = [];\r\n        }\r\n    }\r\n\r\n    switch (data.type) {\r\n        case 'clear':\r\n            currentDatabase.tokens = null;\r\n            currentDatabase.state = null;\r\n            currentDatabase.codeVerifier = null;\r\n            currentDatabase.status = data.data.status;\r\n            port.postMessage({ configurationName });\r\n            return;\r\n        case 'init':\r\n        {\r\n            const oidcServerConfiguration = data.data.oidcServerConfiguration;\r\n            const domains = trustedDomains[configurationName];\r\n            if (!domains.find(f => f === acceptAnyDomainToken)) {\r\n                [oidcServerConfiguration.tokenEndpoint,\r\n                oidcServerConfiguration.revocationEndpoint,\r\n                oidcServerConfiguration.userInfoEndpoint,\r\n                oidcServerConfiguration.issuer].forEach(url => {checkDomain(domains, url);});\r\n            }\r\n            currentDatabase.oidcServerConfiguration = oidcServerConfiguration;\r\n            currentDatabase.oidcConfiguration = data.data.oidcConfiguration;\r\n            const where = data.data.where;\r\n            if (where === 'loginCallbackAsync' || where === 'tryKeepExistingSessionAsync') {\r\n                currentLoginCallbackConfigurationName = configurationName;\r\n            } else {\r\n                currentLoginCallbackConfigurationName = null;\r\n            }\r\n\r\n            if (!currentDatabase.tokens) {\r\n                port.postMessage({\r\n                    tokens: null,\r\n                    status: currentDatabase.status,\r\n                    configurationName,\r\n                });\r\n            } else {\r\n                const tokens = {\r\n                    ...currentDatabase.tokens,\r\n                    access_token: ACCESS_TOKEN + '_' + configurationName,\r\n                };\r\n                if (tokens.refresh_token) {\r\n                    tokens.refresh_token = REFRESH_TOKEN + '_' + configurationName;\r\n                }\r\n                if (tokens.idTokenPayload && tokens.idTokenPayload.nonce && currentDatabase.nonce != null) {\r\n                    tokens.idTokenPayload.nonce = NONCE_TOKEN + '_' + configurationName;\r\n                }\r\n                port.postMessage({\r\n                    tokens,\r\n                    status: currentDatabase.status,\r\n                    configurationName,\r\n                });\r\n            }\r\n            return;\r\n        }\r\n        case 'setState':\r\n            currentDatabase.state = data.data.state;\r\n            port.postMessage({ configurationName });\r\n            return;\r\n        case 'getState':\r\n        {\r\n            const state = currentDatabase.state;\r\n            port.postMessage({ configurationName, state });\r\n            return;\r\n        }\r\n        case 'setCodeVerifier':\r\n            currentDatabase.codeVerifier = data.data.codeVerifier;\r\n            port.postMessage({ configurationName });\r\n            return;\r\n        case 'getCodeVerifier':\r\n        {\r\n            port.postMessage({ configurationName, codeVerifier: CODE_VERIFIER + '_' + configurationName });\r\n            return;\r\n        }\r\n        case 'setSessionState':\r\n            currentDatabase.sessionState = data.data.sessionState;\r\n            port.postMessage({ configurationName });\r\n            return;\r\n        case 'getSessionState':\r\n        {\r\n            const sessionState = currentDatabase.sessionState;\r\n            port.postMessage({ configurationName, sessionState });\r\n            return;\r\n        }\r\n        case 'setNonce':\r\n            currentDatabase.nonce = data.data.nonce;\r\n            port.postMessage({ configurationName });\r\n            return;\r\n        default:\r\n            currentDatabase.items = { ...data.data };\r\n            port.postMessage({ configurationName });\r\n    }\r\n};\r\n\r\n_self.addEventListener('install', handleInstall);\r\n_self.addEventListener('activate', handleActivate);\r\n_self.addEventListener('fetch', handleFetch);\r\n_self.addEventListener('message', handleMessage);\r\n\r\nconst checkDomain = (domains: Domain[], endpoint: string) => {\r\n    if (!endpoint) {\r\n        return;\r\n    }\r\n\r\n    const domain = domains.find((domain) => {\r\n        let testable: RegExp;\r\n\r\n        if (typeof domain === 'string') {\r\n            testable = new RegExp(`^${domain}`);\r\n        } else {\r\n            testable = domain;\r\n        }\r\n\r\n        return testable.test?.(endpoint);\r\n    });\r\n    if (!domain) {\r\n        throw new Error('Domain ' + endpoint + ' is not trusted, please add domain in ' + scriptFilename);\r\n    }\r\n};\r\n"],"names":["_self","scriptFilename","id","acceptAnyDomainToken","keepAliveJsonFilename","handleInstall","event","handleActivate","currentLoginCallbackConfigurationName","database","countLetter","str","find","b64DecodeUnicode","c","parseJwt","token","extractTokenPayload","e","computeTimeLeft","refreshTimeBeforeTokensExpirationInSecond","expiresAt","currentTimeUnixSecond","isTokensValid","tokens","isTokensOidcValid","nonce","oidcServerConfiguration","idTokenPayload","timeInSevenDays","TokenRenewMode","hideTokens","currentDatabaseElement","configurationName","response","accessTokenPayload","secureTokens","ACCESS_TOKEN","_idTokenPayload","keyNonce","NONCE_TOKEN","REFRESH_TOKEN","idTokenExpiresAt","accessTokenExpiresAt","tokenRenewMode","isValid","reason","refreshToken","body","getCurrentDatabasesTokenEndpoint","url","databases","value","openidWellknownUrlEndWith","getCurrentDatabaseDomain","_a","key","currentDatabase","domainsToSendTokens","hasToSendToken","f","i","domain","serializeHeaders","headers","headersObj","CODE_VERIFIER","sleep","ms","resolve","keepAliveAsync","isFromVanilla","init","handleFetch","originalRequest","currentDatabaseForRequestAccessToken","newRequest","currentDatabases","numberDatabase","maPromesse","reject","clonedRequest","actualBody","newBody","currentDb","keyRefreshToken","keyAccessToken","fetchPromise","text","keyCodeVerifier","r","err","handleMessage","port","data","domains","checkDomain","where","state","sessionState","endpoint","testable"],"mappings":"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"}